# SmartyReader Test Configuration
# This configuration is similar to the Arduino test program for debugging P1 data
# It provides raw data inspection and debugging capabilities

esphome:
  name: smartyreader_test
  friendly_name: "SmartyReader Test Mode"

esp8266:
  board: d1_mini_pro

# Enhanced logging for debugging
logger:
  level: VERBOSE
  # Enable serial1 logging on D4 (like Arduino test program)
  hardware_uart: UART1
  logs:
    dsmr: VERBOSE
    uart: VERBOSE
    sensor: DEBUG

# Enable Home Assistant API for monitoring
api:
  encryption:
    key: !secret weigu_api_key

ota:
- platform: esphome
  password: !secret weigu_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "SmartyReader-Test"
    password: "test123456"

captive_portal:

# UART configuration for P1 port
uart:
  - id: uart_bus
    rx_pin:
      number: 3
      inverted: true
    baud_rate: 115200
    rx_buffer_size: 2048
    # Enable debug output to see raw data
    debug:
      direction: RX
      dummy_receiver: true
      after:
        bytes: 512
      sequence:
        - lambda: |-
            // Log raw data in HEX format (similar to Arduino test program)
            std::string hex_string = "";
            for (size_t i = 0; i < bytes.size(); i++) {
              if (i > 0) hex_string += " ";
              hex_string += esphome::str_sprintf("0x%02X", bytes[i]);
              
              // Print line breaks every 25 bytes (like Arduino LINE_LENGTH_RAW_SERIAL)
              if ((i + 1) % 25 == 0) {
                ESP_LOGI("raw_data", "Raw data line %zu: %s", (i + 1) / 25, hex_string.c_str());
                hex_string = "";
              }
            }
            if (!hex_string.empty()) {
              ESP_LOGI("raw_data", "Raw data final: %s", hex_string.c_str());
            }

# DSMR configuration for testing
dsmr:
  id: dsmr_instance
  decryption_key: !secret weigu_dsmr_key
  max_telegram_length: 1800

# Global variables for test statistics
globals:
  - id: telegram_count
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: error_count
    type: uint32_t
    restore_value: no
    initial_value: "0"
  - id: last_telegram_time
    type: uint32_t
    restore_value: no
    initial_value: "0"

# Test sensors to monitor DSMR functionality
sensor:
  # Basic DSMR sensors for testing
  - platform: dsmr
    energy_delivered_lux:
      name: "Test Energy Consumed"
      id: test_energy_consumed
      on_value:
        then:
          - globals.set:
              id: telegram_count
              value: !lambda 'return id(telegram_count) + 1;'
          - globals.set:
              id: last_telegram_time
              value: !lambda 'return millis();'
    power_delivered:
      name: "Test Power Consumed"
      id: test_power_consumed
    voltage_l1:
      name: "Test Voltage L1"
      id: test_voltage_l1
    current_l1:
      name: "Test Current L1"
      id: test_current_l1
    gas_delivered:
      name: "Test Gas Consumed"
      id: test_gas_consumed

  # Test statistics
  - platform: template
    name: "Telegram Count"
    id: telegram_count_sensor
    accuracy_decimals: 0
    lambda: |-
      return id(telegram_count);
    update_interval: 5s

  - platform: template
    name: "Error Count"
    id: error_count_sensor
    accuracy_decimals: 0
    lambda: |-
      return id(error_count);
    update_interval: 5s

  - platform: template
    name: "Seconds Since Last Telegram"
    id: seconds_since_last
    unit_of_measurement: "s"
    accuracy_decimals: 0
    lambda: |-
      uint32_t now = millis();
      uint32_t last = id(last_telegram_time);
      if (last == 0) return 0;
      return (now - last) / 1000;
    update_interval: 1s

  # System monitoring
  - platform: uptime
    name: "Test Uptime"

  - platform: wifi_signal
    name: "Test Wi-Fi Signal"
    update_interval: 30s

# Text sensors for DSMR identification and debugging
text_sensor:
  - platform: dsmr
    identification:
      name: "Test DSMR Identification"
      id: test_identification
      on_value:
        then:
          - logger.log:
              format: "DSMR ID received: %s"
              args: ['x.c_str()']
    p1_version:
      name: "Test DSMR Version"
      id: test_version
      on_value:
        then:
          - logger.log:
              format: "DSMR Version: %s"
              args: ['x.c_str()']

  - platform: template
    name: "Test Status"
    id: test_status
    lambda: |-
      uint32_t now = millis();
      uint32_t last = id(last_telegram_time);
      
      if (last == 0) {
        return std::string("Waiting for first telegram...");
      } else if ((now - last) > 30000) {
        return std::string("ERROR: No data for >30s");
      } else if ((now - last) > 15000) {
        return std::string("WARNING: No data for >15s");
      } else {
        return std::string("OK - Receiving data");
      }
    update_interval: 5s

  - platform: wifi_info
    ip_address:
      name: "Test IP Address"

# Switches for test control
switch:
  - platform: template
    name: "Enable Raw Data Logging"
    id: raw_data_logging
    optimistic: true
    turn_on_action:
      - logger.log: "Raw data logging enabled"
    turn_off_action:
      - logger.log: "Raw data logging disabled"

  - platform: template
    name: "Reset Test Counters"
    id: reset_counters
    turn_on_action:
      - globals.set:
          id: telegram_count
          value: "0"
      - globals.set:
          id: error_count  
          value: "0"
      - globals.set:
          id: last_telegram_time
          value: "0"
      - logger.log: "Test counters reset"
      - switch.turn_off: reset_counters

# Buttons for manual testing
button:
  - platform: restart
    name: "Restart Test Device"

  - platform: template
    name: "Test Log Message"
    on_press:
      - logger.log:
          format: "Test button pressed at %u ms, telegrams: %u, errors: %u"
          args: ['millis()', 'id(telegram_count)', 'id(error_count)']

# Intervals for periodic testing and monitoring
interval:
  # Check for data reception issues
  - interval: 30s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t last = id(last_telegram_time);
          
          if (last > 0 && (now - last) > 30000) {
            ESP_LOGW("test", "No DSMR data received for %u seconds", (now - last) / 1000);
            id(error_count)++;
          }

  # Periodic status report
  - interval: 60s
    then:
      - logger.log:
          format: "Test Status Report - Uptime: %u min, Telegrams: %u, Errors: %u, Last data: %u s ago"
          args: ['(millis() / 60000)', 'id(telegram_count)', 'id(error_count)', '((millis() - id(last_telegram_time)) / 1000)']

# Web server for test interface
web_server:
  port: 80
  include_internal: true

# Debug LED
status_led:
  pin:
    number: LED_BUILTIN
    inverted: true